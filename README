
Last edit: 2020 Dec 14th 5:35 PM

These java files aim to provide simulation of a DNS client, a DNS server
and an attacker that aims to cache poisoning the DNS client.

---------------------------------------------------------------------------------
------------- Guide and Experiment Setup: Simple_DNS_Client/Sever ---------------
Topology setup: See project_mininet_v0.py.
    link between a host and a switch has 15 Mbps bandwidth, 1 ms delay.
    link between two switches has 15 Mbps bandwidth, 10 ms delay.

**************** Experiment running guide: *****************
First: running floodlight VM, open a terminal, run following commands:
        cd floodlight
        ant #(If you haven't)
        java -jar /target/floodlight.jar

Copy all project code to a directory, e.g. 00_04_project_repo/

Open another terminal, run following commands:
        cd Desktop/00_04_project_repo
        rm -rf *.class
        javac Simple_Java_Udp.java
        sudo mn -c #(If need password, it is "floodlight")
        sudo python project_mininet_v0.py

Now mininet should start running, run following command:
        xterm h1 h2 h3

On h1's terminal, type following command (do not press "enter" yet):
        java Simple_Java_Udp dnsClient 10.0.0.3 12345 10.0.0.2 23456

On h2's terminal, type following command (do not press "enter yet)":
        java Simple_Java_Udp dnsAttacker 10.0.0.2 23456

On h3's terminal, type following command, and run it
        java Simple_Java_Udp dnsServer 10.0.0.3 12345

Now go back to h2 FIRST, run it. THEN go back to h1, run it.
************************************************************


******************** Simple_DNS_Server: ********************
This class represents a server that handles a DNS query. Default setting is to run
    as authoritative server. By changeModeToAttacker() method, it will run as an
    attacker.
Difference between server and attacker is how we simulate the send method.

For server: in 80% of time, after received client query, server waits 50 ms, then
    it sends data to server. In 20% of time, server waits (50 - x) ms, where
    10 <= x < 45.
By experimental observation, under such setting, the estimated Round Trip Time
    between h1(client) and h3(server) is ~140 ms.

For attacker: in 80% of time, attacker immediately sends response back to client.
    In 20% of time, attacker waits X ms, where 95 <= X < 125 ms. Then it sends
    response back to client.

In experimental observation, these setting can simulate cases, when both
    attacker's and server's response fall in window time.
    e.g. Attacker's response RTT: 141 ms; 142 ms; 138 ms; 130 ms;
         Server's response RTT:   149 ms; 139 ms; 144 ms; 141 ms;
************************************************************


******************** Simple_DNS_Client: ********************
This client creates a DNS query, sends to server, and waits for response.

For current simulation, client will first establish statistics for server.
    This is done by creating an AuthServerStats object, and tries to send
    20 packets to server, get response, update the server statistics.
    SEE BELOW FOR INFO ABOUT AuthServerStats/PacketStats.

To simulate attacker eavesdropping the message. For each query, client sends
    two identical query packet. One to attacker, one to server.

The client then waits for response, if one response received, client waits for
    window time, calculated from server statistics. If another packet arrives,
    run our version of dfp_rescue method. To see which one of the packet comes
    from server.
************************************************************
------------- Guide and Experiment Setup: Simple_DNS_Client/Sever ---------------
---------------------------------------------------------------------------------




---------------------------------------------------------------------------------
-------------------- Guide for AuthServerStats/PacketStats ----------------------
*********************** AuthServerStats: ***********************
This class stands statistics for a server. Including estimated Round Trip time,
    deviation of Round Trip Time.

When a packet arrives, after calculate its Round Trip Time(RTT), we use server
    statistics to determine how long we should wait for another packet.
We also determine if a packet is an early packet, by using info in this class.
****************************************************************


******************** AuthServerPacketStats: ********************
This class stands for packet statistics.

If we receive two response packets, lets say - PACKET A and PACKET B,
    for one query. They come from different sources, have expected domain name
    we look for in query. Then we need to created two packet statistics
    instances for these two response packets.

Then client start dfp_rescue method: It resend the query to server, and waits for
    response.

For any response client receives, it check if that response come from any one of
    the packet A/B's source. We update that packet statistics info.

The main info we need to update, is "whether the received packet fall within
    window time".

After client re-send query multiple times, it check the two packet statistics.

By our theory and experiment setup, packet from actual server has higher chance
    that its RTT fall within window time, i.e., not come too early.

Thus, by comparing packet statistics info, we hope to figure out, which packet
    A or B, comes from actual server.
****************************************************************
-------------------- Guide for AuthServerStats/PacketStats ----------------------
---------------------------------------------------------------------------------





------------- Quick guide to DNS message encoding/ decoding ---------------
The comments I made before should provide some explanation about different classes,
as well as how they work together. But for quick catch up, I will leave some introduction
here as well.

Methods in BigEndianEncoder, BigEndianDecoder are used to encode/decode part of a
DNS packet. Notice that, java UDP socket sends an array of bytes, and receives an
array of bytes. So methods in these classes aim to help us convert a string, or a number,
to some bytes, in big Endian order. Or help us obtain a number, a string(like IP address)
from part of a byte array.

DNSMessage is the class to represent a DNS message, it has a DNSHeader, a DNSQuestion,
and three DNSResourceRecords. Each DNSResourceRecords has a list of DNSResourceRecord.

These lists represent Answer, Authority (typically, these are name server info)
Additional Info field. Defined in rfc 1035.

Each resource record(here the class is DNSResourceRecord) has 5 fields:
name: a DNSName object, contains info of a domain name like "www.uwo.ca";
type: type of the resource record, our project will only use type A,
        which stands for an IPv4 address in rdata.
class: this field is not important for our project.
rdLength: length of rdata. For type A, length will be 4 bytes.
rdata: for type A resource record, this is a 4-byte integer,
        represents an IPv4 address.

NOTE: Right now, the code can encode a DNS query (a DNS Message with a header,
    a question, but no answers, authorities, or additional info).
The code can build a DNS response message based on the query. You can add more
    than one type A resource record to any one of the answers,
    authorities(name servers), or additional section.
    DO NOT USE OTHER RECORD TYPE.

In Simple_java_Udp, check testEncodeDecode() method. That
    method provides some examples about how to use the methods.

Where to begin with:

I suggest you use an IDE to build a project, so that you can follow the call trace.
You can start looking at DNSMessage. The comments should be very helpful.

Also, go to the Simple_Java_Udp.java file, there are some example usages inside the
main() method and testEncodeDecode..
-----------------------------------------------------------------------------------


------------- Quick guide to Simple UDP client/ server ---------------
The main() method, as mentioned before, is in Simple_Java_Udp.java

****After you compile the code on floodlight VM, to run as a server. use:
    "java Simple_Java_Udp server server-host port"
Where sver-host can be "localhost",
or ip address like "10.0.0.3" (when running on host h3 under mininet).
Port is the port number you setup for the sever, like "12345"

Once sever start running, server waits for message from client. After you
typed something on client's terminal, server should able to receive it.

Now you need to press a key like "c" to continue.If you type "quit",
you can quit the server.
****To run as a client. use:
    "java Simple_Java_Udp client server-host port"
Now if you type something on client's terminal, it should be sent to sever.
If you type "quit", you can quit the client.

NOTE: Please check "Guide and Experiment Setup: Simple_DNS_Client/Server".
--------------------------------------------------------------------------------


// for reference purpose, if needed.
Some of the code are referenced from Wumian Wang's previous project, which
built a simple DNS resolver that can encode a DNS packet, send to a DNS server,
receive DNS response message and decode it.

Here we acknowledge that method for encoding and decoding a DNS message
are adapted from the previous work's framework.
-------------------

Summary: Now we have implemented out version of dfp, further adjustment will
    based on experiment requirements.

Possible TODO:
    1. Make output to a text file;
    2. adjust experiment setup;